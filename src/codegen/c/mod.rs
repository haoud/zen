use crate::{
    ast,
    codegen::c::scope::Scope,
    lang::{self, Spanned},
};

pub mod scope;

/// The code generator for the C backend. This struct is used to generate
/// the C code from the AST. It keeps track of the current scope depth
/// and the generated code.
#[derive(Debug)]
pub struct Codegen {
    /// The generated code
    code: String,

    /// The stack of scopes. The first scope in the stack is the global scope, and
    /// the last scope in the stack is the current scope.
    scopes: Vec<Scope>,
}

impl Codegen {
    /// Create a new empty code generator
    #[must_use]
    pub fn new() -> Self {
        Self {
            scopes: vec![Scope::global()],
            code: String::new(),
        }
    }

    /// Return the global scope object. This is the scope with depth 0, where all the
    /// global variables and functions are defined.
    ///
    /// # Panics
    /// This function should never panic since the global scope should always be present, and
    /// functions that manipulate the scope stack ensure that at least the global scope is always
    /// present.
    #[must_use]
    pub fn global_scope(&self) -> &Scope {
        self.scopes.first().unwrap()
    }

    /// Return the current scope object. This is the scope at the top of the scope stack,
    /// where the current variables and functions are defined. If there is no local scope,
    /// this will return the global scope instead.
    ///
    /// # Panics
    /// This function should never panic since the scope stack should always contain at least
    /// the global scope, and functions that manipulate the scope stack ensure that at least
    /// the global scope is always present.
    #[must_use]
    pub fn current_scope(&self) -> &Scope {
        self.scopes.last().unwrap()
    }

    /// Enter a new scope. This will create a new scope object with a depth
    /// one greater than the current scope, and push it onto the scope stack.
    pub fn enter_scope(&mut self) {
        let new_scope = Scope::new(self.current_scope());
        self.scopes.push(new_scope);
    }

    /// Exit the current scope and return to the previous scope.
    ///
    /// # Panics
    /// This function will panic if the caller attempts to exit the global scope.
    pub fn exit_scope(&mut self) {
        assert!(self.scopes.len() > 1);
        self.scopes.pop();
    }

    /// Execute the given closure `f` in a new scope. This will automatically enter
    /// a new scope before executing the closure, and exit the scope after the closure
    /// has been executed. This is useful for generating code that requires a new
    /// scope, such as function bodies or blocks.
    pub fn scoped<F, R>(&mut self, f: F) -> R
    where
        F: FnOnce(&mut Self) -> R,
    {
        self.enter_scope();
        let result = f(self);
        self.exit_scope();
        result
    }

    /// Generate the comment header at the top of the generated C file.
    pub fn generate_comment_header(&mut self) {
        self.code += "/**\n";
        self.code += " * This file was generated by the Zen compiler. Do not edit this\n";
        self.code += " * file directly, as changes may create unexpected behavior in\n";
        self.code += " * the generated code.\n";
        self.code += " */\n";
    }

    /// Generate the necessary includes for the generated C code.
    pub fn generate_includes(&mut self) {
        self.code += "#include <stdbool.h>\n";
        self.code += "#include <stddef.h>\n\n";
    }

    /// Add a newline to the generated code. This is useful to separate different parts of
    /// the code and make it more readable.
    pub fn add_separator(&mut self) {
        self.code += "\n";
    }

    /// Indent the future line of code by adding tabs to the generated code depending on the
    /// current scope depth.
    pub fn indent_codegen(&mut self) {
        for _ in 0..self.current_scope().depth() {
            self.code += "\t";
        }
    }

    /// Generate the function header. This function will generate the function return type,
    /// name and parameters. If the `prototype` flag is set to `true`, the function will
    /// add a semicolon at the end of the function declaration.
    pub fn generate_fn_header(&mut self, func: &ast::Function, prototype: bool) {
        // Generate the function return type and name
        self.code += "int ";
        self.code += func.prototype.ident.name;
        self.code += "(";

        // If this is a prototype, we need to add a semicolon at the
        // end of the function declaration.
        if prototype {
            self.code += ");\n";
        } else {
            self.code += ")\n";
        }
    }

    /// Generate the function body. This function will generate the function body by iterating
    /// over the function statements and generating the corresponding C code.
    pub fn generate_fn(&mut self, func: &ast::Function) {
        self.generate_fn_header(func, false);
        self.scoped(|codegen| {
            codegen.code += "{\n";
            for stmt in &func.body {
                let code = &codegen.generate_stmt(stmt);
                codegen.indent_codegen();
                codegen.code += code;
                codegen.code += "\n";
            }
            codegen.code += "}\n";
        });
    }

    /// Generate the C code for the given statement. This function will recursively generate the
    /// C code for the statement and its children. It will return the generated C code as a string.
    #[must_use]
    pub fn generate_stmt(&mut self, stmt: &ast::Stmt) -> String {
        match &stmt.kind {
            ast::StmtKind::Return(expr) => {
                format!("return {};", self.generate_expr(expr))
            }
            ast::StmtKind::Let(ident, ty, expr) => {
                let ctype = self.generate_type(ty);
                let value = self.generate_expr(expr);
                format!("const {ctype} {ident} = {value};", ident = ident.name)
            }
            ast::StmtKind::Var(ident, ty, expr) => {
                let ctype = self.generate_type(ty);
                let value = self.generate_expr(expr);
                format!("{ctype} {ident} = {value};", ident = ident.name)
            }
            ast::StmtKind::Assign(ident, expr) => {
                let expr = self.generate_expr(expr);
                format!("{ident} = {expr};", ident = ident.name)
            }
            ast::StmtKind::Error(..) => unreachable!(),
        }
    }

    /// Generate the C code for the given expression. This function will recursively generate the
    /// C code for the expression and its children. It will return the generated C code as a string.
    #[must_use]
    pub fn generate_expr(&mut self, expr: &ast::Expr) -> String {
        match &expr.kind {
            ast::ExprKind::Identifier(identifier) => identifier.name.to_string(),
            ast::ExprKind::Literal(literal) => format!("{}", literal.value),
            ast::ExprKind::Bool(b) => {
                if b.0 {
                    "true".to_string()
                } else {
                    "false".to_string()
                }
            }
            ast::ExprKind::Binary(op, lhs, rhs) => {
                let lexpr = self.generate_expr(lhs);
                let rexpr = self.generate_expr(rhs);
                let op = op.as_str();
                format!("({lexpr} {op} {rexpr})")
            }
            ast::ExprKind::Unary(op, expr) => {
                let expr = self.generate_expr(expr);
                let op = op.as_str();
                format!("({op}{expr})")
            }
            ast::ExprKind::Error(..) => unreachable!(),
        }
    }

    /// Convert the built-in Zen types to C types.
    ///
    /// # Panics
    /// This function will panic if the type is `Never` or `Infer` is passed to the function:
    ///  - The type checker should have remplaced all Infer types by concrete
    ///    types before the code generation phase.
    ///  - The Never type has no equivalent in C and should not be used in the
    ///    generated code, since it represents an value that can never be
    ///    constructed.
    pub fn generate_type(&mut self, ty: &lang::Type) -> String {
        match ty {
            lang::Type::Bool => "bool".to_string(),
            lang::Type::Int => "int".to_string(),
            lang::Type::Unknown => {
                unreachable!("Type::Unknown should not appear in the code generation phase")
            }
            lang::Type::Infer => {
                unreachable!("Type::Infer should not appear in the code generation phase")
            }
        }
    }
}

impl Default for Codegen {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate the C code for the given list of functions. This function will create a new
/// code generator, generate the function prototypes and bodies, and return the generated
/// C code as a string.
#[must_use]
pub fn generate(funcs: &[Spanned<ast::Function>]) -> String {
    let mut codegen = Codegen::new();
    codegen.generate_comment_header();
    codegen.generate_includes();

    // Generate the function prototypes at the top of the file to avoid having to
    // worry about the order of the functions in the source code. That way, all
    // functions are declared before they are used. No need for a header file :)
    for func in funcs {
        codegen.generate_fn_header(func, true);
    }

    // Generate all the functions
    codegen.add_separator();
    for func in funcs {
        codegen.generate_fn(func);
        codegen.add_separator();
    }

    codegen.code
}
