use crate::c::scope::Scope;

pub mod intrinsic;
pub mod scope;

/// The code generator for the C backend. This struct is used to generate
/// the C code from the AST. It keeps track of the current scope depth
/// and the generated code.
#[derive(Debug)]
pub struct Codegen {
    /// The generated code
    code: String,

    /// The stack of scopes. The first scope in the stack is the global scope, and
    /// the last scope in the stack is the current scope.
    scopes: Vec<Scope>,
}

impl Codegen {
    /// Create a new empty code generator
    #[must_use]
    pub fn new() -> Self {
        Self {
            scopes: vec![Scope::global()],
            code: String::new(),
        }
    }

    /// Return the global scope object. This is the scope with depth 0, where all the
    /// global variables and functions are defined.
    ///
    /// # Panics
    /// This function should never panic since the global scope should always be present, and
    /// functions that manipulate the scope stack ensure that at least the global scope is always
    /// present.
    #[must_use]
    pub fn global_scope(&self) -> &Scope {
        self.scopes.first().unwrap()
    }

    /// Return the current scope object. This is the scope at the top of the scope stack,
    /// where the current variables and functions are defined. If there is no local scope,
    /// this will return the global scope instead.
    ///
    /// # Panics
    /// This function should never panic since the scope stack should always contain at least
    /// the global scope, and functions that manipulate the scope stack ensure that at least
    /// the global scope is always present.
    #[must_use]
    pub fn current_scope(&self) -> &Scope {
        self.scopes.last().unwrap()
    }

    /// Enter a new scope. This will create a new scope object with a depth
    /// one greater than the current scope, and push it onto the scope stack.
    pub fn enter_scope(&mut self) {
        let new_scope = Scope::new(self.current_scope());
        self.scopes.push(new_scope);
    }

    /// Exit the current scope and return to the previous scope.
    ///
    /// # Panics
    /// This function will panic if the caller attempts to exit the global scope.
    pub fn exit_scope(&mut self) {
        assert!(self.scopes.len() > 1);
        self.scopes.pop();
    }

    /// Execute the given closure `f` in a new scope. This will automatically enter
    /// a new scope before executing the closure, and exit the scope after the closure
    /// has been executed. This is useful for generating code that requires a new
    /// scope, such as function bodies or blocks.
    pub fn scoped<F, R>(&mut self, f: F) -> R
    where
        F: FnOnce(&mut Self) -> R,
    {
        self.enter_scope();
        let result = f(self);
        self.exit_scope();
        result
    }

    /// Generate the comment header at the top of the generated C file.
    pub fn generate_comment_header(&mut self) {
        self.code += "/**\n";
        self.code += " * This file was generated by the Zen compiler. Do not edit this\n";
        self.code += " * file directly, as changes may create unexpected behavior in\n";
        self.code += " * the generated code.\n";
        self.code += " */\n";
    }

    /// Generate the necessary includes for the generated C code.
    pub fn generate_includes(&mut self) {
        self.code += "#include <stdio.h>\n";
        self.code += "#include <stdbool.h>\n";
        self.code += "#include <stddef.h>\n\n";
    }

    /// Add a newline to the generated code. This is useful to separate different parts of
    /// the code and make it more readable.
    pub fn add_separator(&mut self) {
        self.code += "\n";
    }

    /// Generate the indentation for the current scope depth. This will return a string
    /// containing the appropriate number of tab characters for the current scope depth.
    #[must_use]
    pub fn indent_codegen(&self) -> String {
        "\t".repeat(self.current_scope().depth())
    }

    /// Generate the function header. This function will generate the function return type,
    /// name and parameters. If the `prototype` flag is set to `true`, the function will
    /// add a semicolon at the end of the function declaration.
    pub fn generate_fn_header(&mut self, func: &ast::Function, prototype: bool) {
        let ret = self.generate_type(&func.prototype.ret);

        // Generate the function return type and name
        self.code += &ret.0; // FIXME: Handle arrays in return types
        self.code += " ";
        self.code += func.prototype.ident.name;
        self.code += "(";

        // Generate the function parameters
        let args = &func
            .prototype
            .params
            .iter()
            .map(|param| {
                let mutable = if !param.mutable { "const " } else { "" };
                let (ty, array) = self.generate_type(&param.ty);
                let name = &param.ident.name;
                format!("{mutable}{ty} {name}{array}")
            })
            .collect::<Vec<_>>()
            .join(", ");
        self.code += args;

        // If this is a prototype, we need to add a semicolon at the
        // end of the function declaration.
        if prototype {
            self.code += ");\n";
        } else {
            self.code += ")\n";
        }
    }

    /// Generate the function body. This function will generate the function body by iterating
    /// over the function statements and generating the corresponding C code.
    pub fn generate_fn(&mut self, func: &ast::Function) {
        self.generate_fn_header(func, false);
        self.scoped(|codegen| {
            codegen.code += "{\n";
            for stmt in &func.body {
                let code = &codegen.generate_stmt(stmt);
                codegen.code += &codegen.indent_codegen();
                codegen.code += code;
                codegen.code += "\n";
            }
            codegen.code += "}\n";
        });
    }

    /// Generate the C code for the given statement. This function will recursively generate the
    /// C code for the statement and its children. It will return the generated C code as a string.
    #[must_use]
    pub fn generate_stmt(&mut self, stmt: &ast::Stmt) -> String {
        match &stmt.kind {
            ast::StmtKind::Return(expr) => {
                if let Some(expr) = expr.as_ref() {
                    format!("return {};", self.generate_expr(expr, false))
                } else {
                    "return;".to_string()
                }
            }
            ast::StmtKind::Let(ident, ty, expr) => {
                let (ctype, array) = self.generate_type(ty);
                let value = self.generate_expr(expr, false);
                format!(
                    "const {ctype} {ident}{array}  = {value};",
                    ident = ident.name
                )
            }
            ast::StmtKind::Var(ident, ty, expr) => {
                let (ctype, array) = self.generate_type(ty);
                let value = self.generate_expr(expr, false);
                format!("{ctype} {ident}{array} = {value};", ident = ident.name)
            }
            ast::StmtKind::Assign(op, ident, expr) => {
                let op = op.as_ref().map(lang::BinaryOp::as_str).unwrap_or("");
                let expr = self.generate_expr(expr, false);
                format!("{ident} {op}= {expr};", ident = ident.name,)
            }
            ast::StmtKind::If(cond, then_block, else_block) => {
                let cond = self.generate_expr(cond, false);
                let then_block = self.generate_block(then_block);
                let else_block = else_block
                    .as_ref()
                    .map(|else_blk| format!(" else {}", self.generate_block(else_blk)))
                    .unwrap_or_default();
                format!("if ({cond}) {then_block}{else_block}")
            }
            ast::StmtKind::While(cond, body) => {
                let cond = self.generate_expr(cond, false);
                let body = self.generate_block(body);
                format!("while ({cond}) {body}")
            }
            ast::StmtKind::Expr(expr) => {
                let expr = self.generate_expr(expr, false);
                format!("{expr};")
            }
            ast::StmtKind::Error(..) => unreachable!(),
        }
    }

    /// Generate the C code for the given block of statements. This function will recursively
    /// generate the C code for the block and its statements. It will return the generated
    /// C code as a string.
    #[must_use]
    pub fn generate_block(&mut self, block: &ast::Block) -> String {
        let mut code = String::new();

        code += "{\n";
        self.scoped(|codegen| {
            for stmt in &block.stmts {
                let stmt_code = codegen.generate_stmt(stmt);
                code += &codegen.indent_codegen();
                code += &stmt_code;
                code += "\n";
            }
        });

        // Handle the case of an empty block to generate an more readable code.
        if block.stmts.is_empty() {
            self.scoped(|codegen| {
                code += &codegen.indent_codegen();
                code += "// empty block\n";
            });
        }

        code += &self.indent_codegen();
        code += "}";
        code
    }

    /// Generate the C code for the given expression. This function will recursively generate the
    /// C code for the expression and its children. It will return the generated C code as a string.
    #[must_use]
    pub fn generate_expr(&mut self, expr: &ast::Expr, compound: bool) -> String {
        match &expr.kind {
            ast::ExprKind::Identifier(identifier) => identifier.name.to_string(),
            ast::ExprKind::Literal(literal) => format!("{}", literal.value),
            ast::ExprKind::String(s) => format!("\"{}\"", s.0),
            ast::ExprKind::List(items) => {
                let list_ty = self.generate_type(&expr.ty);
                let compound_ty = if compound {
                    format!("({}{})", list_ty.0, list_ty.1)
                } else {
                    "".to_string()
                };

                let items = items
                    .iter()
                    .map(|item| self.generate_expr(item, false))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{} {{{}}}", compound_ty, items)
            }
            ast::ExprKind::Bool(b) => {
                if b.0 {
                    "true".to_string()
                } else {
                    "false".to_string()
                }
            }
            ast::ExprKind::Binary(op, lhs, rhs) => {
                let lexpr = self.generate_expr(lhs, false);
                let rexpr = self.generate_expr(rhs, false);
                let op = op.as_str();
                format!("({lexpr} {op} {rexpr})")
            }
            ast::ExprKind::Unary(op, expr) => {
                let expr = self.generate_expr(expr, false);
                let op = op.as_str();
                format!("({op}{expr})")
            }
            ast::ExprKind::FunctionCall(ident, args) => {
                let args = args
                    .iter()
                    .map(|arg| self.generate_expr(arg, true))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}({})", ident.name, args)
            }
            ast::ExprKind::IntrinsicCall(ident, args) => match ident.name {
                "println" | "print" => {
                    let newline = ident.name == "println";
                    let s = args[0].kind.as_string_literal().unwrap();
                    let fmt = intrinsic::generate_fmt_string(s, &args[1..]);
                    let fmt_args = args[1..]
                        .iter()
                        .map(|arg| self.generate_fmt_args(arg))
                        .collect::<Vec<_>>()
                        .join(", ");

                    // Generate the appropriate printf call based on whether there are
                    // arguments to print or not, and whether a newline is needed.
                    if fmt_args.is_empty() {
                        if newline {
                            format!("printf(\"{}\\n\")", fmt)
                        } else {
                            format!("printf(\"{}\")", fmt)
                        }
                    } else if newline {
                        format!("printf(\"{}\\n\", {})", fmt, fmt_args)
                    } else {
                        format!("printf(\"{}\", {})", fmt, fmt_args)
                    }
                }
                _ => unreachable!(),
            },
            ast::ExprKind::Error(..) => unreachable!(),
        }
    }

    /// Convert the built-in Zen types to C types.
    ///
    /// # Returns
    /// A tuple containing the C type as a string and any additional information needed for
    /// the type (e.g. for declaring arrays).
    ///
    /// # Panics
    /// This function will panic if the type is `Never` or `Infer` is passed to the function:
    ///  - The type checker should have remplaced all Infer types by concrete
    ///    types before the code generation phase.
    ///  - The Never type has no equivalent in C and should not be used in the
    ///    generated code, since it represents an value that can never be
    ///    constructed.
    pub fn generate_type(&mut self, ty: &lang::ty::Type) -> (String, String) {
        match ty {
            lang::ty::Type::Void => ("void".to_string(), "".to_string()),
            lang::ty::Type::Str => ("char *".to_string(), "".to_string()),
            lang::ty::Type::Bool => ("bool".to_string(), "".to_string()),
            lang::ty::Type::Int => ("int".to_string(), "".to_string()),
            lang::ty::Type::Array(ty, size) => {
                let ctype = self.generate_type(ty);
                (ctype.0, format!("[{}]", size))
            }
            lang::ty::Type::Unknown => {
                unreachable!("Type::Unknown should not appear in the code generation phase")
            }
            lang::ty::Type::Infer => {
                unreachable!("Type::Infer should not appear in the code generation phase")
            }
        }
    }
}

impl Default for Codegen {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate the C code for the given list of functions. This function will create a new
/// code generator, generate the function prototypes and bodies, and return the generated
/// C code as a string.
#[must_use]
pub fn generate(funcs: &[lang::Spanned<ast::Function>]) -> String {
    let mut codegen = Codegen::new();
    codegen.generate_comment_header();
    codegen.generate_includes();

    // Generate the function prototypes at the top of the file to avoid having to
    // worry about the order of the functions in the source code. That way, all
    // functions are declared before they are used. No need for a header file :)
    for func in funcs {
        codegen.generate_fn_header(func, true);
    }

    // Generate all the functions
    codegen.add_separator();
    for func in funcs {
        codegen.generate_fn(func);
        codegen.add_separator();
    }

    codegen.code
}
